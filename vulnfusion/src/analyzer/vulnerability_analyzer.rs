// 中文说明：
// VulnerabilityAnalyzer 负责协调“文件发现→解析→图构建→漏洞检测→结果汇总”
// 的整体流程；支持并行/顺序两种模式，并记录性能指标与上下文信息。
use crate::utils::error::Result;
use std::path::{Path, PathBuf};
use std::sync::Arc;
use std::sync::RwLock;
use tracing::{info, debug, warn};
use rayon::prelude::*;

use crate::analyzer::{
    AnalysisConfig, AnalysisResults, AnalysisContext, AnalysisPrecision,
};
use crate::parser::RustParser;
use crate::detector::VulnerabilityDetector;
use crate::graph::AnalysisGraph;

pub struct VulnerabilityAnalyzer {
    config: AnalysisConfig,
    parser: Arc<RustParser>,
    detector: Arc<VulnerabilityDetector>,
    graph: Arc<RwLock<AnalysisGraph>>,
}

impl VulnerabilityAnalyzer {
    pub fn new() -> Self {
        Self::with_config(AnalysisConfig::default())
    }
    
    pub fn with_config(config: AnalysisConfig) -> Self {
        let parser = Arc::new(RustParser::new());
        let detector = Arc::new(VulnerabilityDetector::new(config.clone()));
        let graph = Arc::new(RwLock::new(AnalysisGraph::new()));
        
        Self {
            config,
            parser,
            detector,
            graph,
        }
    }
    
    // 当配置发生变化时重建检测器，确保阈值/过滤设置即时生效
    fn rebuild_detector(&mut self) {
        self.detector = Arc::new(VulnerabilityDetector::new(self.config.clone()));
    }
    
    pub fn set_parallel(&mut self, parallel: bool) {
        self.config.parallel_analysis = parallel;
        self.rebuild_detector();
    }
    
    pub fn set_depth(&mut self, depth: &str) {
        self.config.max_depth = match depth {
            "shallow" => 3,
            "normal" => 7,
            "deep" => 15,
            _ => 10,
        };
        self.rebuild_detector();
    }
    
    pub fn set_thread_count(&mut self, threads: usize) {
        self.config.thread_count = threads;
        self.rebuild_detector();
    }
    
    pub fn set_excluded_paths(&mut self, paths: Vec<String>) {
        for path in paths {
            self.config.add_excluded_path(path);
        }
        self.rebuild_detector();
    }
    
    pub fn set_vulnerability_filters(&mut self, filters: Vec<String>) {
        for filter in filters {
            self.config.add_vulnerability_filter(filter);
        }
        self.rebuild_detector();
    }

    pub fn set_min_confidence(&mut self, v: f64) {
        self.config.set_min_confidence(v);
        self.rebuild_detector();
    }

    pub fn set_min_severity_level(&mut self, lvl: i32) {
        self.config.set_min_severity_level(lvl);
        self.rebuild_detector();
    }

    pub fn set_min_severity_str(&mut self, s: &str) {
        let lvl = match s.to_lowercase().as_str() {
            "info" => 0,
            "low" => 1,
            "medium" => 2,
            "high" => 3,
            "critical" => 4,
            _ => 1,
        };
        self.config.set_min_severity_level(lvl);
        self.rebuild_detector();
    }
    
    pub async fn analyze(&self, project_path: &Path) -> Result<AnalysisResults> {
        // 主入口：对目标工程进行漏洞分析，返回汇总结果
        info!("Starting vulnerability analysis for: {}", project_path.display());
        
        let start_time = std::time::Instant::now();
        let mut context = AnalysisContext::new(project_path.to_string_lossy().to_string());
        let mut results = AnalysisResults::new(context.clone());
        
        // Discover Rust files
        let rust_files = self.discover_rust_files(project_path).await?;
        info!("Found {} Rust files to analyze", rust_files.len());
        
        if rust_files.is_empty() {
            warn!("No Rust files found in the specified path");
            return Ok(results);
        }
        
        // Parse and analyze files
        if self.config.parallel_analysis {
            self.analyze_parallel(&rust_files, &mut results).await?;
        } else {
            self.analyze_sequential(&rust_files, &mut results).await?;
        }
        
        results.statistics.total_files_analyzed = rust_files.len();
        let mut total_lines = 0usize;
        let mut total_unsafe = 0usize;
        for p in &rust_files {
            if let Ok(content) = std::fs::read_to_string(p) {
                total_lines += content.lines().count();
                total_unsafe += content.matches("unsafe").count();
            }
        }
        results.statistics.total_lines_of_code = total_lines;
        results.context.unsafe_blocks_found = total_unsafe;
        results.context.files_analyzed = rust_files.len();
        results.context.finish();
        
        // Calculate performance metrics
        let duration = start_time.elapsed();
        results.performance_metrics.analysis_duration_ms = duration.as_millis() as u64;
        
        info!("Analysis completed in {:?}", duration);
        info!("Found {} potential vulnerabilities", results.vulnerabilities.len());
        
        Ok(results)
    }
    
    async fn discover_rust_files(&self, project_path: &Path) -> Result<Vec<PathBuf>> {
        // 递归遍历工程，发现 .rs 文件；支持路径排除与测试文件跳过
        use walkdir::WalkDir;
        
        let mut rust_files = Vec::new();
        
        for entry in WalkDir::new(project_path)
            .follow_links(true)
            .into_iter()
            .filter_map(|e| e.ok())
        {
            let path = entry.path();
            
            // Skip excluded paths
            if self.config.is_path_excluded(path.to_string_lossy().as_ref()) {
                debug!("Skipping excluded path: {}", path.display());
                continue;
            }
            
            // Check if it's a Rust file
            if path.extension().and_then(|s| s.to_str()) == Some("rs") {
                // Skip unit test files and tests directory only
                if !self.config.include_dependencies {
                    let fname = path.file_name().and_then(|s| s.to_str()).unwrap_or("");
                    let in_tests_dir = {
                        let ps = path.to_string_lossy();
                        ps.contains("/tests/") || ps.contains("\\tests\\")
                    };
                    let is_test_file = fname.ends_with("_test.rs") || fname.ends_with(".test.rs");
                    if in_tests_dir || is_test_file {
                        debug!("Skipping test file: {}", path.display());
                        continue;
                    }
                }
                
                rust_files.push(path.to_path_buf());
            }
        }
        
        Ok(rust_files)
    }
    
    async fn analyze_parallel(&self, files: &[PathBuf], results: &mut AnalysisResults) -> Result<()> {
        // 并行分析：按线程数把文件切片，map-reduce 合并漏洞结果
        info!("Running parallel analysis with {} threads", self.get_thread_count());
        
        let chunks: Vec<&[PathBuf]> = files.chunks(self.get_chunk_size(files.len())).collect();
        
        let vuln_results: Vec<Vec<crate::analyzer::Vulnerability>> = chunks
            .par_iter()
            .map(|chunk| {
                let mut chunk_vulns = Vec::new();
                
                for file_path in *chunk {
                    match self.analyze_single_file(file_path) {
                        Ok(vulns) => chunk_vulns.extend(vulns),
                        Err(e) => warn!("Failed to analyze {}: {}", file_path.display(), e),
                    }
                }
                
                chunk_vulns
            })
            .collect();
        
        // Combine results
        for vulns in vuln_results {
            results.add_vulnerabilities(vulns);
        }
        
        Ok(())
    }
    
    async fn analyze_sequential(&self, files: &[PathBuf], results: &mut AnalysisResults) -> Result<()> {
        // 顺序分析：逐个文件解析并检测，适用于小型工程或调试
        info!("Running sequential analysis");
        
        for (i, file_path) in files.iter().enumerate() {
            debug!("Analyzing file {}/{}: {}", i + 1, files.len(), file_path.display());
            
            match self.analyze_single_file(file_path) {
                Ok(vulns) => results.add_vulnerabilities(vulns),
                Err(e) => warn!("Failed to analyze {}: {}", file_path.display(), e),
            }
        }
        
        Ok(())
    }
    
    fn analyze_single_file(&self, file_path: &Path) -> Result<Vec<crate::analyzer::Vulnerability>> {
        // 单文件分析：解析 AST → 构建分析图 → 运行检测器
        // Parse the Rust file
        let ast = self.parser.parse_file(file_path)?;
        
        // Build analysis graph
        let mut graph = self.graph.write().unwrap();
        graph.build_from_ast(&ast)?;
        
        // Run vulnerability detection
        let vulnerabilities = self.detector.detect_vulnerabilities(&ast, &graph)?;
        
        Ok(vulnerabilities)
    }
    
    fn get_thread_count(&self) -> usize {
        if self.config.thread_count == 0 {
            rayon::current_num_threads()
        } else {
            self.config.thread_count
        }
    }
    
    fn get_chunk_size(&self, total_files: usize) -> usize {
        let thread_count = self.get_thread_count();
        (total_files + thread_count - 1) / thread_count
    }
}