// 中文说明：
// VulnerabilityDetector 统一调度各类具体检测器（内存安全、并发、panic、安全模式），
// 并对结果做置信度过滤与按严重程度排序，形成最终的漏洞清单。
use crate::utils::error::Result;
use std::sync::Arc;
use tracing::{debug, info};

use crate::analyzer::{AnalysisConfig, AnalysisPrecision, Vulnerability, VulnerabilitySeverity, DetectionMethod};
use crate::parser::RustAst;
use crate::graph::AnalysisGraph;
use crate::detector::{
    MemorySafetyDetector,
    ConcurrencyDetector,
    PanicSafetyDetector,
    PatternDetector,
};

pub struct VulnerabilityDetector {
    config: AnalysisConfig,
    memory_detector: Arc<MemorySafetyDetector>,
    concurrency_detector: Arc<ConcurrencyDetector>,
    panic_detector: Arc<PanicSafetyDetector>,
    pattern_detector: Arc<PatternDetector>,
}

impl VulnerabilityDetector {
    pub fn new(config: AnalysisConfig) -> Self {
        Self {
            config: config.clone(),
            memory_detector: Arc::new(MemorySafetyDetector::new(config.clone())),
            concurrency_detector: Arc::new(ConcurrencyDetector::new(config.clone())),
            panic_detector: Arc::new(PanicSafetyDetector::new(config.clone())),
            pattern_detector: Arc::new(PatternDetector::new(config)),
        }
    }
    
    pub fn detect_vulnerabilities(&self, ast: &RustAst, graph: &AnalysisGraph) -> Result<Vec<Vulnerability>> {
        // 对单个 AST+分析图运行各类检测器，并汇总结果
        let mut vulnerabilities = Vec::new();
        
        debug!("Starting vulnerability detection for: {}", ast.file_path);
        
        // Memory safety detection
        if self.should_detect_type("memory-safety") {
            info!("Running memory safety detection");
            let memory_vulns = self.memory_detector.detect(ast, graph)?;
            vulnerabilities.extend(memory_vulns);
        }
        
        // Concurrency detection
        if self.should_detect_type("concurrency") {
            info!("Running concurrency detection");
            let concurrency_vulns = self.concurrency_detector.detect(ast, graph)?;
            vulnerabilities.extend(concurrency_vulns);
        }
        
        // Panic safety detection
        if self.should_detect_type("panic-safety") {
            info!("Running panic safety detection");
            let panic_vulns = self.panic_detector.detect(ast, graph)?;
            vulnerabilities.extend(panic_vulns);
        }
        
        // Pattern-based detection
        if self.should_detect_type("pattern") {
            info!("Running pattern-based detection");
            let pattern_vulns = self.pattern_detector.detect(ast, graph)?;
            vulnerabilities.extend(pattern_vulns);
        }
        
        for v in &mut vulnerabilities {
            self.adjust_confidence(v);
        }
        vulnerabilities.retain(|v| v.confidence >= self.get_effective_min_confidence());
        vulnerabilities.retain(|v| self.severity_to_int(&v.severity) >= self.config.min_severity_level);
        
        // Sort by severity and confidence
        vulnerabilities.sort_by(|a, b| {
            let severity_cmp = self.severity_to_int(&b.severity).cmp(&self.severity_to_int(&a.severity));
            if severity_cmp == std::cmp::Ordering::Equal {
                b.confidence.partial_cmp(&a.confidence).unwrap_or(std::cmp::Ordering::Equal)
            } else {
                severity_cmp
            }
        });
        
        info!("Detected {} vulnerabilities in {}", vulnerabilities.len(), ast.file_path);
        
        Ok(vulnerabilities)
    }
    
    fn should_detect_type(&self, vuln_type: &str) -> bool {
        self.config.should_analyze_vulnerability(vuln_type)
    }
    
    fn get_effective_min_confidence(&self) -> f64 {
        if self.config.min_confidence > 0.0 { self.config.min_confidence } else {
            match self.config.analysis_precision {
                AnalysisPrecision::Shallow => 0.8,
                AnalysisPrecision::Normal => 0.7,
                AnalysisPrecision::Deep => 0.6,
                AnalysisPrecision::Exhaustive => 0.5,
            }
        }
    }
    
    fn severity_to_int(&self, severity: &VulnerabilitySeverity) -> i32 {
        // 将严重程度映射为排序用整数
        match severity {
            VulnerabilitySeverity::Critical => 4,
            VulnerabilitySeverity::High => 3,
            VulnerabilitySeverity::Medium => 2,
            VulnerabilitySeverity::Low => 1,
            VulnerabilitySeverity::Info => 0,
        }
    }

    fn adjust_confidence(&self, v: &mut Vulnerability) {
        let s = v.code_snippet.to_lowercase();
        match v.vulnerability_type.as_str() {
            "data-race" => {
                if s.contains("mutex") || s.contains("rwlock") || s.contains("atomic") || s.contains("std::sync::") {
                    v.confidence = (v.confidence - 0.2).max(0.0);
                }
            }
            "improper-sync" => {
                if s.contains("where") && (s.contains("send") || s.contains("sync")) {
                    v.confidence = (v.confidence - 0.3).max(0.0);
                }
                if s.contains("<") && (s.contains(": send") || s.contains(": sync")) {
                    v.confidence = (v.confidence - 0.3).max(0.0);
                }
                if s.contains("safety:") {
                    v.confidence = (v.confidence - 0.5).max(0.0);
                }
            }
            "buffer-overflow" => {
                if s.contains(".len()") || s.contains("debug_assert!") || s.contains("assert!(") {
                    v.confidence = (v.confidence - 0.2).max(0.0);
                }
                let re_const_idx = regex::Regex::new(r"get_unchecked\s*\(\s*(\d+)\s*\)").ok();
                if let Some(re) = re_const_idx.as_ref() {
                    if let Some(caps) = re.captures(&s) {
                        if let Ok(k) = caps.get(1).map(|m| m.as_str()).unwrap_or("").parse::<usize>() {
                            if k < 16 { v.confidence = (v.confidence - 0.3).max(0.0); }
                        }
                    }
                }
            }
            "panic-safety" => {
                if !(s.contains("panic!(") || s.contains("unwrap(") || s.contains("expect(") ) {
                    v.confidence = (v.confidence - 0.2).max(0.0);
                }
            }
            _ => {}
        }
    }
}

// Helper functions for creating vulnerabilities
pub fn create_vulnerability(
    vuln_type: String,
    severity: VulnerabilitySeverity,
    confidence: f64,
    file_path: String,
    line_number: usize,
    description: String,
    detailed_explanation: String,
    remediation_suggestion: String,
    code_snippet: String,
    detection_method: DetectionMethod,
) -> Vulnerability {
    // 构造统一的漏洞结构体，便于后续报告生成与归档
    Vulnerability {
        id: format!("VULN-{}-{}", line_number, crate::utils::helpers::current_timestamp()),
        vulnerability_type: vuln_type,
        severity,
        confidence,
        file_path,
        line_number,
        column_number: None,
        description,
        detailed_explanation,
        remediation_suggestion,
        code_snippet,
        related_code_locations: Vec::new(),
        detection_method,
        metadata: std::collections::HashMap::new(),
        detected_at: crate::utils::helpers::current_timestamp(),
    }
}